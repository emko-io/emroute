/**
 * Widget Discovery + Manifest Generation
 *
 * Two levels of discovery:
 * 1. Full widget discovery — scans widgetsDir/ for {name}/{name}.widget.ts
 *    modules and their companion files. Generates a WidgetsManifest.
 * 2. Companion file discovery — finds {name}.widget.{html,md,css} for
 *    already-known widgets. Legacy API, still supported.
 */

import type { WidgetManifestEntry } from '../../src/type/widget.type.ts';
import type { Runtime } from '../../runtime/abstract.runtime.ts';
import { escapeForCodeString } from './route.generator.ts';

type WidgetFiles = { html?: string; md?: string; css?: string };

const COMPANION_EXTENSIONS = ['html', 'md', 'css'] as const;
const WIDGET_FILE_SUFFIX = '.widget.ts';

/**
 * Discover widget modules and companion files by scanning a directory.
 *
 * Walks `widgetsDir/` looking for `{name}/{name}.widget.ts`. For each
 * discovered module, also checks for companion files (html, md, css).
 *
 * @param widgetsDir  Directory containing widget subdirectories.
 * @param runtime     Runtime for filesystem access.
 * @param pathPrefix  Prefix for paths in the manifest (e.g. 'widgets').
 * @returns Array of WidgetManifestEntry with name, modulePath, tagName, files.
 */
export async function discoverWidgets(
  widgetsDir: string,
  runtime: Runtime,
  pathPrefix?: string,
): Promise<WidgetManifestEntry[]> {
  const entries: WidgetManifestEntry[] = [];

  const trailingDir = widgetsDir.endsWith('/') ? widgetsDir : widgetsDir + '/';
  const response = await runtime.query(trailingDir);
  const listing: string[] = await response.json();

  for (const item of listing) {
    if (!item.endsWith('/')) continue; // only directories

    const name = item.slice(0, -1); // strip trailing /
    const moduleFile = `${name}${WIDGET_FILE_SUFFIX}`;
    const modulePath = `${trailingDir}${name}/${moduleFile}`;

    if ((await runtime.query(modulePath)).status === 404) continue;

    const prefix = pathPrefix ? `${pathPrefix}/` : '';
    const entry: WidgetManifestEntry = {
      name,
      modulePath: `${prefix}${name}/${moduleFile}`,
      tagName: `widget-${name}`,
    };

    // Discover companion files
    const files: WidgetFiles = {};
    let hasFiles = false;
    for (const ext of COMPANION_EXTENSIONS) {
      const companionFile = `${name}.widget.${ext}`;
      const companionPath = `${trailingDir}${name}/${companionFile}`;
      if ((await runtime.query(companionPath)).status !== 404) {
        files[ext] = `${prefix}${name}/${companionFile}`;
        hasFiles = true;
      }
    }

    if (hasFiles) entry.files = files;
    entries.push(entry);
  }

  // Sort by name for stable output
  entries.sort((a, b) => a.name.localeCompare(b.name));

  return entries;
}

/**
 * Generate TypeScript source for a full widgets manifest module.
 *
 * Produces a typed module with widget entries and module loaders:
 * ```ts
 * import type { WidgetsManifest } from '@emkodev/emroute';
 * export const widgetsManifest: WidgetsManifest = { ... };
 * ```
 */
export function generateWidgetsManifestCode(
  entries: WidgetManifestEntry[],
  importPath = '@emkodev/emroute',
  /** Directory where the manifest file will be written (for resolving relative imports). */
  manifestDir = '',
): string {
  const stripPrefix = manifestDir ? manifestDir.replace(/\/$/, '') + '/' : '';
  const strip = (p: string): string =>
    stripPrefix && p.startsWith(stripPrefix) ? p.slice(stripPrefix.length) : p;

  const widgetEntries = entries.map((e) => {
    const filesStr = e.files
      ? `\n      files: { ${
        Object.entries(e.files)
          .filter(([_, v]) => v)
          .map(([k, v]) => `${k}: '${escapeForCodeString(strip(v!))}'`)
          .join(', ')
      } },`
      : '';

    return `    {
      name: '${escapeForCodeString(e.name)}',
      modulePath: '${escapeForCodeString(strip(e.modulePath))}',
      tagName: '${escapeForCodeString(e.tagName)}',${filesStr}
    }`;
  }).join(',\n');

  const loaderEntries = entries.map((e) => {
    const key = strip(e.modulePath);
    const rel = key.replace(/^\.\//, '');
    return `    '${escapeForCodeString(key)}': () => import('./${escapeForCodeString(rel)}'),`;
  }).join('\n');

  return `/**
 * Generated Widgets Manifest
 *
 * DO NOT EDIT - This file is auto-generated by widget.generator.ts
 */

import type { WidgetsManifest } from '${escapeForCodeString(importPath)}';

export const widgetsManifest: WidgetsManifest = {
  widgets: [
${widgetEntries}
  ],

  moduleLoaders: {
${loaderEntries}
  },
};
`;
}
