/**
 * Widget Discovery + Manifest Generation
 *
 * Two levels of discovery:
 * 1. Full widget discovery — scans widgetsDir/ for {name}/{name}.widget.ts
 *    modules and their companion files. Generates a WidgetsManifest.
 * 2. Companion file discovery — finds {name}.widget.{html,md,css} for
 *    already-known widgets. Legacy API, still supported.
 */

import type { WidgetManifestEntry } from '../src/type/widget.type.ts';
import type { FileSystem } from './fs.type.ts';

type WidgetFiles = { html?: string; md?: string; css?: string };

const COMPANION_EXTENSIONS = ['html', 'md', 'css'] as const;
const WIDGET_FILE_SUFFIX = '.widget.ts';

/**
 * Discover companion files for widgets on the filesystem.
 *
 * For each widget, checks for `{widgetsDir}/{name}/{name}.widget.{html,md,css}`.
 * Merges per-key with explicit `widget.files` — explicit values win per file type,
 * discovered values fill gaps. Does **not** mutate inputs.
 *
 * @deprecated Use {@link discoverWidgets} instead, which discovers both modules
 *   and companion files in a single pass.
 * @param widgetsDir  Absolute or relative directory containing widget subdirectories.
 * @param widgets     Iterable of widgets with name and optional declared files.
 * @param fs          FileSystem abstraction for checking file existence.
 * @param pathPrefix  Prefix for paths in the returned map (e.g. 'widgets').
 * @returns Map of widget name → merged file paths.
 */
export async function discoverWidgetFiles(
  widgetsDir: string,
  widgets: Iterable<{ name: string; files?: WidgetFiles }>,
  fs: FileSystem,
  pathPrefix?: string,
): Promise<Map<string, WidgetFiles>> {
  const result = new Map<string, WidgetFiles>();

  const discoveries = [];

  for (const widget of widgets) {
    discoveries.push(discoverForWidget(widgetsDir, widget, fs, pathPrefix));
  }

  const entries = await Promise.all(discoveries);

  for (const entry of entries) {
    if (entry) {
      result.set(entry.name, entry.files);
    }
  }

  return result;
}

async function discoverForWidget(
  widgetsDir: string,
  widget: { name: string; files?: WidgetFiles },
  fs: FileSystem,
  pathPrefix?: string,
): Promise<{ name: string; files: WidgetFiles } | undefined> {
  const discovered: WidgetFiles = {};
  let hasAny = false;

  for (const ext of COMPANION_EXTENSIONS) {
    const filename = `${widget.name}.widget.${ext}`;
    const fullPath = `${widgetsDir}/${widget.name}/${filename}`;

    if (await fs.exists(fullPath)) {
      const prefix = pathPrefix ? `${pathPrefix}/` : '';
      discovered[ext] = `${prefix}${widget.name}/${filename}`;
      hasAny = true;
    }
  }

  // Merge: discovered fills gaps, explicit wins per key
  const declared = widget.files ?? {};
  const merged = { ...discovered, ...declared };
  const hasMerged = merged.html || merged.md || merged.css;

  if (!hasAny && !hasMerged) return undefined;

  return { name: widget.name, files: merged };
}

/**
 * Generate TypeScript source for a widget-files manifest module.
 *
 * Produces a plain data module with no imports or side effects:
 * ```ts
 * export const widgetFiles: Record<string, { html?: string; md?: string; css?: string }> = { ... };
 * ```
 *
 * @deprecated Use {@link generateWidgetsManifestCode} instead, which produces a
 *   full WidgetsManifest with module loaders.
 */
export function generateWidgetFilesManifestCode(
  discoveredFiles: Map<string, WidgetFiles>,
): string {
  const entries: string[] = [];

  for (const [name, files] of discoveredFiles) {
    const props: string[] = [];
    if (files.html) props.push(`html: '${files.html}'`);
    if (files.md) props.push(`md: '${files.md}'`);
    if (files.css) props.push(`css: '${files.css}'`);

    if (props.length === 0) continue;

    if (props.length === 1) {
      entries.push(`  '${name}': { ${props[0]} },`);
    } else {
      entries.push(`  '${name}': {\n    ${props.join(',\n    ')},\n  },`);
    }
  }

  return `/** Auto-generated by discoverWidgetFiles — do not edit. */
export const widgetFiles: Record<string, { html?: string; md?: string; css?: string }> = {
${entries.join('\n')}
};
`;
}

// ---------------------------------------------------------------------------
// Full widget discovery — scans for .widget.ts modules + companion files
// ---------------------------------------------------------------------------

/**
 * Discover widget modules and companion files by scanning a directory.
 *
 * Walks `widgetsDir/` looking for `{name}/{name}.widget.ts`. For each
 * discovered module, also checks for companion files (html, md, css).
 *
 * @param widgetsDir  Directory containing widget subdirectories.
 * @param fs          FileSystem abstraction.
 * @param pathPrefix  Prefix for paths in the manifest (e.g. 'widgets').
 * @returns Array of WidgetManifestEntry with name, modulePath, tagName, files.
 */
export async function discoverWidgets(
  widgetsDir: string,
  fs: FileSystem,
  pathPrefix?: string,
): Promise<WidgetManifestEntry[]> {
  const entries: WidgetManifestEntry[] = [];

  for await (const dirEntry of fs.readDir(widgetsDir)) {
    if (!dirEntry.isDirectory) continue;

    const name = dirEntry.name;
    const moduleFile = `${name}${WIDGET_FILE_SUFFIX}`;
    const modulePath = `${widgetsDir}/${name}/${moduleFile}`;

    if (!await fs.exists(modulePath)) continue;

    const prefix = pathPrefix ? `${pathPrefix}/` : '';
    const entry: WidgetManifestEntry = {
      name,
      modulePath: `${prefix}${name}/${moduleFile}`,
      tagName: `widget-${name}`,
    };

    // Discover companion files
    const files: WidgetFiles = {};
    let hasFiles = false;
    for (const ext of COMPANION_EXTENSIONS) {
      const companionFile = `${name}.widget.${ext}`;
      const companionPath = `${widgetsDir}/${name}/${companionFile}`;
      if (await fs.exists(companionPath)) {
        files[ext] = `${prefix}${name}/${companionFile}`;
        hasFiles = true;
      }
    }

    if (hasFiles) entry.files = files;
    entries.push(entry);
  }

  // Sort by name for stable output
  entries.sort((a, b) => a.name.localeCompare(b.name));

  return entries;
}

function escapeForCodeString(value: string): string {
  return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

/**
 * Generate TypeScript source for a full widgets manifest module.
 *
 * Produces a typed module with widget entries and module loaders:
 * ```ts
 * import type { WidgetsManifest } from '@emkodev/emroute';
 * export const widgetsManifest: WidgetsManifest = { ... };
 * ```
 */
export function generateWidgetsManifestCode(
  entries: WidgetManifestEntry[],
  importPath = '@emkodev/emroute',
  /** Directory where the manifest file will be written (for resolving relative imports). */
  manifestDir = '',
): string {
  const stripPrefix = manifestDir ? manifestDir.replace(/\/$/, '') + '/' : '';
  const strip = (p: string): string =>
    stripPrefix && p.startsWith(stripPrefix) ? p.slice(stripPrefix.length) : p;

  const widgetEntries = entries.map((e) => {
    const filesStr = e.files
      ? `\n      files: { ${
        Object.entries(e.files)
          .filter(([_, v]) => v)
          .map(([k, v]) => `${k}: '${escapeForCodeString(strip(v!))}'`)
          .join(', ')
      } },`
      : '';

    return `    {
      name: '${escapeForCodeString(e.name)}',
      modulePath: '${escapeForCodeString(strip(e.modulePath))}',
      tagName: '${escapeForCodeString(e.tagName)}',${filesStr}
    }`;
  }).join(',\n');

  const loaderEntries = entries.map((e) => {
    const key = strip(e.modulePath);
    const rel = key.replace(/^\.\//, '');
    return `    '${escapeForCodeString(key)}': () => import('./${escapeForCodeString(rel)}'),`;
  }).join('\n');

  return `/**
 * Generated Widgets Manifest
 *
 * DO NOT EDIT - This file is auto-generated by widget.generator.ts
 */

import type { WidgetsManifest } from '${escapeForCodeString(importPath)}';

export const widgetsManifest: WidgetsManifest = {
  widgets: [
${widgetEntries}
  ],

  moduleLoaders: {
${loaderEntries}
  },
};
`;
}
