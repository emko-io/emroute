/**
 * Widget File Discovery + Manifest Generation
 *
 * Discovers companion files ({name}.widget.{html,md,css}) for widgets
 * on disk, and generates a TypeScript manifest for SPA bundles.
 */

import type { FileSystem } from './fs.type.ts';

type WidgetFiles = { html?: string; md?: string; css?: string };

const EXTENSIONS = ['html', 'md', 'css'] as const;

/**
 * Discover companion files for widgets on the filesystem.
 *
 * For each widget, checks for `{widgetsDir}/{name}/{name}.widget.{html,md,css}`.
 * Merges per-key with explicit `widget.files` — explicit values win per file type,
 * discovered values fill gaps. Does **not** mutate inputs.
 *
 * @param widgetsDir  Absolute or relative directory containing widget subdirectories.
 * @param widgets     Iterable of widgets with name and optional declared files.
 * @param fs          FileSystem abstraction for checking file existence.
 * @param pathPrefix  Prefix for paths in the returned map (e.g. 'widgets').
 * @returns Map of widget name → merged file paths.
 */
export async function discoverWidgetFiles(
  widgetsDir: string,
  widgets: Iterable<{ name: string; files?: WidgetFiles }>,
  fs: FileSystem,
  pathPrefix?: string,
): Promise<Map<string, WidgetFiles>> {
  const result = new Map<string, WidgetFiles>();

  const discoveries = [];

  for (const widget of widgets) {
    discoveries.push(discoverForWidget(widgetsDir, widget, fs, pathPrefix));
  }

  const entries = await Promise.all(discoveries);

  for (const entry of entries) {
    if (entry) {
      result.set(entry.name, entry.files);
    }
  }

  return result;
}

async function discoverForWidget(
  widgetsDir: string,
  widget: { name: string; files?: WidgetFiles },
  fs: FileSystem,
  pathPrefix?: string,
): Promise<{ name: string; files: WidgetFiles } | undefined> {
  const discovered: WidgetFiles = {};
  let hasAny = false;

  for (const ext of EXTENSIONS) {
    const filename = `${widget.name}.widget.${ext}`;
    const fullPath = `${widgetsDir}/${widget.name}/${filename}`;

    if (await fs.exists(fullPath)) {
      const prefix = pathPrefix ? `${pathPrefix}/` : '';
      discovered[ext] = `${prefix}${widget.name}/${filename}`;
      hasAny = true;
    }
  }

  // Merge: discovered fills gaps, explicit wins per key
  const declared = widget.files ?? {};
  const merged = { ...discovered, ...declared };
  const hasMerged = merged.html || merged.md || merged.css;

  if (!hasAny && !hasMerged) return undefined;

  return { name: widget.name, files: merged };
}

/**
 * Generate TypeScript source for a widget-files manifest module.
 *
 * Produces a plain data module with no imports or side effects:
 * ```ts
 * export const widgetFiles: Record<string, { html?: string; md?: string; css?: string }> = { ... };
 * ```
 */
export function generateWidgetFilesManifestCode(
  discoveredFiles: Map<string, WidgetFiles>,
): string {
  const entries: string[] = [];

  for (const [name, files] of discoveredFiles) {
    const props: string[] = [];
    if (files.html) props.push(`html: '${files.html}'`);
    if (files.md) props.push(`md: '${files.md}'`);
    if (files.css) props.push(`css: '${files.css}'`);

    if (props.length === 0) continue;

    if (props.length === 1) {
      entries.push(`  '${name}': { ${props[0]} },`);
    } else {
      entries.push(`  '${name}': {\n    ${props.join(',\n    ')},\n  },`);
    }
  }

  return `/** Auto-generated by discoverWidgetFiles — do not edit. */
export const widgetFiles: Record<string, { html?: string; md?: string; css?: string }> = {
${entries.join('\n')}
};
`;
}
